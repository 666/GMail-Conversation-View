<!DOCTYPE html>

<html>

<head>
  <title>Conversation Reader</title>
  <link rel="stylesheet" type="text/css" href="chrome://messenger/skin/tagColors.css"/>
  <link rel="stylesheet" type="text/css" href="chrome://conversations/skin/conversation.css">
  <script type="text/javascript" src="chrome://conversations/content/js/jquery-1.4.2.min.js"></script>
  <script type="text/javascript" src="chrome://conversations/content/js/jquery.text-overflow.js"></script>
  <script type="application/javascript;version=1.8">
    (function ($) {
      $.fn.vAlign = function(container) {
        return this.each(function(i){
          if(container == null) {
            container = 'div';
          }
          $(this).html("<" + container + ">" + $(this).html() + "</" + container + ">");
          var el = $(this).children(container + ":first");
          var elh = $(el).height(); //new element height
          var ph = $(this).height(); //parent height
          var nh = (ph - elh) / 2; //new height to apply
          $(el).css('margin-top', nh);
        });
      };
    })(jQuery);

    function alignAttachments(aMsgNode) {
      $(aMsgNode._domNode).find(".align").vAlign();
    }

    function scrollNodeIntoView (aNode) {
      let offset = aNode.offsetTop || 0;
      let parent = aNode.parentNode;
      while (parent && !(parent instanceof HTMLDocument)) {
        let style = window.getComputedStyle(parent, null);
        if (style.position == "relative")
          offset += parent.offsetTop;
        parent = parent.parentNode;
      }
      // The header is 44px high (yes, this is harcodeadly ugly).
      window.scrollTo(0, offset + 5 - 44);
    }

    function toggleQuote(event, showquotedtext, hidequotedtext) {
      let link = event.target;
      let div = link.nextSibling;
      let cs = window.getComputedStyle(div, null);
      if (div.style.display == "none") {
        link.textContent = "- "+hidequotedtext+" -";
        div.style.display = "";
        let h = div.getBoundingClientRect().height +
          parseFloat(cs.marginTop) + parseFloat(cs.marginBottom);
        return h;
      } else {
        let h = div.getBoundingClientRect().height;
        h += parseFloat(cs.marginTop);
        h += parseFloat(cs.marginBottom);
        link.textContent = "- "+showquotedtext+" -";
        div.style.display = "none";
        return -h;
      }
    }

    const kPopupTimeout = 500;

    function enableTooltips(aMsg) {
      let $aMsgNode = $(aMsg._domNode);
      $aMsgNode.find('.tooltip').each(function (i) {
        // "details" is a hypothetical "details" link that, when
        //   hovered/clicked, starts the interaction with the tooltip
        let $tooltip = $(this);
        let $details = $tooltip.prev();

        let sticky = false;
        let timeout;
        /* $details.get(0).addEventListener("click", function (event) {
          sticky = !sticky;
          event.stopPropagation();
        }, false); */
        $details.hover(
          function() {
            if (aMsg.collapsed)
              return;
            if (!sticky) {
              clearTimeout(timeout);
              let self = this;
              timeout = setTimeout(function () {
                $(self).next(':hidden').fadeIn();
              }, kPopupTimeout);
            }
          },
          function() {
            var self = this;
            if (!sticky) {
              clearTimeout(timeout);
              timeout = setTimeout(function () {
                $(self).next(/*':visible'*/).fadeOut()
              }, kPopupTimeout);
            }
          });
        $tooltip.hover(
          function () {
            clearTimeout(timeout);
          },
          function () {
            var self = this;
            if ($(this).is(":visible") && !sticky) {
              clearTimeout(timeout);
              timeout = setTimeout(function () {
                $(self).fadeOut();
              }, kPopupTimeout);
            }
          });
      });
    }

    // This property is now set from the outside. This allows stub.html to
    //  be used either in a standalone tab or in the multimessage pane.
    // let Conversations = window.top.Conversations;
    Components.utils.import("resource://conversations/MsgHdrUtils.jsm");
    Components.utils.import("resource://conversations/prefs.js");
    Components.utils.import("resource://conversations/log.js");

    let Log = setupLogging("Conversations.Stub");

    // Mark the current conversation as read/unread. The conversation driver
    //  takes care of setting the right class on us whenever the state
    //  changes...
    function toggleRead(event) {
      let $span = $(event.target).find("span.read");
      if ($span.hasClass("unread")) {
        Conversations.currentConversation.read = true;
        $span.removeClass("unread");
      } else {
        Conversations.currentConversation.read = false;
        $span.addClass("unread");
      }
    }

    function expandCollapse(event) {
      let $span = $(event.target).find("span.expand");
      if ($span.hasClass("collapse")) {
        [message.collapse()
          for each ([, { message }] in Iterator(Conversations.currentConversation.messages))];
        $span.removeClass("collapse");
      } else {
        [message.expand()
          for each ([, { message }] in Iterator(Conversations.currentConversation.messages))];
        $span.addClass("collapse");
      }
    }

    function archiveConversation(event) {
      msgHdrsArchive(Conversations.currentConversation.msgHdrs);
    }

    function deleteConversation(event) {
      msgHdrsDelete(Conversations.currentConversation.msgHdrs);
    }

    function detachTab(event) {
      let mainWindow = getMail3Pane();
      let tabmail = mainWindow.document.getElementById("tabmail");
      tabmail.openTab("conversationTab", {
        onLoad: function _detachTab_onLoad (event, browser) {
          try {
            browser.contentWindow.Conversations = {
              currentConversation: null,
              counter: 0,
            };
            // Pick _initialSet and not msgHdrs so as to enforce the invariant
            //  that the messages from _initialSet are in the current view.
            let freshConversation = new mainWindow.Conversations.monkeyPatch._Conversation(
              browser.contentWindow,
              Conversations.currentConversation._initialSet,
              Prefs.kScrollUnreadOrLast,
              ++browser.contentWindow.Conversations.counter
            );
            freshConversation.outputInto(browser, function (aConversation) {
              browser.contentWindow.Conversations.currentConversation = aConversation;
            });
          } catch (e) {
            Log.debug(e);
            dumpCallStack(e);
          }
        }
      });
    }

    // Setting the second parameter to false means don't fire a stupid timer
    //  that lives forever everytime we call this function.
    function fakeTextOverflowSubject() {
      $(".subject").textOverflow(null, false);
    }

    function fakeTextOverflowParticipants(aMsgNode) {
      $(aMsgNode).find(".to").textOverflow(null, false);
    }

    function cleanup() {
      Log.debug("Cleaning up jquery's mess...");
      // These shouldn't be necessary because we're blasting away everything by
      //  setting .innerHTML BUT jQuery won't remove its persistent event
      //  listeners if we don't do that which will in turn cause memory leaks!
      // Indeed, the listeners are actually closures on Message instances. These
      //  contain a pointer to their parent Conversation, so that would prevent
      //  the GC from collecting anything! Argh!
      $("#messageList").empty();
    }

    document.addEventListener("focus", function (event) {
      /* This is a persistent event listener. It can operate multiple
       * times. We have the invariant that for a given conversation, there's at
       * most one such element (recycling doesn't use tabindex 1). */
      let msgNode = document.querySelector(".message[tabindex=\"1\"]");
      if (!msgNode)
        return;

      /* Restore the proper tab order. This event is fired *after* the
       * right message has been focused in Gecko 1.9.2, *before* the right
       * message has been focused in Gecko 1.9.1 (so it's basically
       * useless). */
      let msgNodes = document.getElementsByClassName("message");
      let index;
      for each (let [i, k] in Iterator(msgNodes)) {
        if (k == msgNode) {
          index = i;
          break;
        }
      }
      if (index)
        msgNode.setAttribute("tabindex", index+2);
    }, true);
  </script>
</head>

<body>
  <div id="wrapper">
    <div id="conversationHeaderWrapper">
      <div id="conversationHeader" class="hbox">
        <div class="subject boxFlex">This is an example of a subject</div>
        <div class="actions">
          <button title="Delete this conversation" onclick="deleteConversation(event);">
            <img src="i/trash.png" />
          </button>
          <button title="Archive this conversation" onclick="archiveConversation(event);">
            <img src="i/archive.png" />
          </button>
          <button title="Expand/collapse all messages" onclick="expandCollapse(event);">
            <span class="expand"></span>
          </button>
          <button title="Toggle read/unread all messages" onclick="toggleRead(event);">
            <span class="read"></span>
          </button>
          <button title="Save this conversation in a new tab" onclick="detachTab(event);">
            <img src="i/tab.png" />
          </button>
          <!--<button><span class="mode"></span></button>-->
        </div>
      </div>
    </div>
    <ul id="messageList">
    </ul>
  </div>
</body>
</html>
